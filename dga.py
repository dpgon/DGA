from datetime import datetime, timedelta
import DGAs
import re
from DGAs import *


class Col:
    HEADER = '\033[95m\033[1m'
    INFO = '\033[96m'
    OK = '\033[92m'
    WARNING = '\033[93m'
    ERROR = '\033[91m'
    END = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'


def configs(malware):
    return eval(malware).DGA.configs


def samples(malware):
    return eval(malware).DGA.samples


def use_date(malware):
    return eval(malware).DGA.use_date


def show(malware, data):
    if data == 'name':
        return eval(malware).DGA.name
    elif data == 'ref':
        return eval(malware).DGA.ref
    elif data == 'desc':
        return eval(malware).DGA.desc
    elif data == 'samples':
        return eval(malware).DGA.samples
    elif data == 'lcg':
        return eval(malware).DGA.lcg
    elif data == 'use_date':
        return eval(malware).DGA.use_date
    elif data == 'use_seed':
        return eval(malware).DGA.use_seed
    elif data == 'configs':
        return eval(malware).DGA.configs
    elif data == 'variation':
        return eval(malware).DGA.variation
    elif data == 'regex':
        return eval(malware).DGA.regex
    elif data == 'ends':
        return eval(malware).DGA.ends


def info(malware, main=False):
    text = ""
    for item in malware:
        text += Col.HEADER + f"{eval(item).DGA.name}\n{'=' * len(eval(item).DGA.name)}\n" + Col.END
        for ref in eval(item).DGA.ref:
            text += f"{ref}\n"
        text += f"\n{eval(item).DGA.desc}\n"
        if eval(item).DGA.yara:
            text += f"  * Yara rule: {eval(item).DGA.yara}\n"
        else:
            text += f"  * No yara rules\n"
        if eval(item).DGA.lcg:
            text += f"  * LCG: {eval(item).DGA.lcg}\n"
        else:
            text += f"  * No LCG\n"
        if eval(item).DGA.use_date:
            if eval(item).DGA.use_date > 1:
                text += f"  * Date affected: every {eval(item).DGA.use_date} days\n"
            else:
                text += f"  * Date affected: every day\n"
        else:
            text += f"  * No affected by date\n"
        if eval(item).DGA.use_seed:
            text += f"  * Seed: {eval(item).DGA.use_seed}\n"
        else:
            text += f"  * Doesn't use seed\n"
        if eval(item).DGA.samples:
            text += f"  * Max samples per date: {eval(item).DGA.samples}\n"
        else:
            text += f"  * No samples limit number\n"
        if eval(item).DGA.variation:
            text += f"  * Variation of the DGA: {eval(item).DGA.variation}\n"
        if len(eval(item).DGA.ends) == 1:
            text += f"  * Possible TLD: {eval(item).DGA.ends}\n"
        else:
            text += f"  * Possible TLD:\n"
            for end in eval(item).DGA.ends:
                text += f"    - {end}\n"
        if eval(item).DGA.regex:
            text += f"  * Domain regular expresion: "
            regexp = eval(item).DGA.regex
            if len(eval(item).DGA.ends) > 1:
                regexp += "("
                for tld in eval(item).DGA.ends:
                    regexp += tld + "|"
                regexp = regexp[:-1] + ")"
            else:
                regexp += eval(item).DGA.ends[0]
            text += f"{regexp}\n\n"
    if main:
        print(text)
    else:
        return text


def detect(malware, domains, brute=False, main=False):
    if not main:
        brute = True
    families = []
    for domain in domains:
        found = False
        for family in malware:
            regexp = eval(family).DGA.regex
            if len(eval(family).DGA.ends) > 1:
                regexp += "("
                for tld in eval(family).DGA.ends:
                    regexp += tld + "|"
                regexp = regexp[:-1] + ")"
            else:
                regexp += eval(family).DGA.ends[0]
            ans = re.match(regexp, domain)
            if ans:
                found = True
                if brute:
                    families.append(family)
                if main:
                    print(f"{domain} could be generated by {eval(family).DGA.name}")
        if main and not found:
            print(f"{domain} not seems DGA generated")
    return families


def bruteforce(families, domains, init_date, seed, nr, days=366, last=True, main=False):
    ret = []
    for domain in domains:
        malware = detect(families, [domain], brute=True)
        found_domain = False
        for family in malware:
            for config in eval(family).DGA.configs:
                if not init_date:
                    date = datetime.now()
                else:
                    date = init_date
                found_family = False
                if eval(family).DGA.use_date:
                    delta = timedelta(eval(family).DGA.use_date)
                    loop = days // eval(family).DGA.use_date
                else:
                    delta = 0
                    loop = 1
                for _ in range(loop):
                    if seed:
                        dga = eval(family).DGA(date=date, seed=seed)
                    elif config:
                        dga = eval(family).DGA(date=date, seed=config)
                    else:
                        dga = eval(family).DGA(date=date)
                    if dga.samples == 0 or dga.samples > nr:
                        loop2 = nr
                    else:
                        loop2 = dga.samples
                    for pos in range(loop2):
                        d = dga.get_domain()
                        if domain == d:
                            if main:
                                if delta and config:
                                    print(f"{family}: Domain {domain} with config {config} is in {pos+1} position "
                                          f"of the day {date.strftime('%Y-%m-%d')}")
                                elif delta:
                                    print(f"{family}: Domain {domain} is in {pos+1} position "
                                          f"of the day {date.strftime('%Y-%m-%d')}")
                                elif config:
                                    print(f"{family}: Domain {domain} with config {config} is in {pos + 1} position")
                                else:
                                    print(f"{family}: Domain {domain} is in {pos + 1} position")
                            else:
                                ret.append([domain, family, pos+1, date])
                            if last:
                                found_domain = True
                                found_family = True
                                break
                    del dga
                    if delta:
                        date = date - delta
                    if found_family:
                        break
        if main and not found_domain:
            print(f"Domain {domain} not founded")
    return ret


def listall(main=False):
    if main:
        for item in DGAs.__all__:
            print(f"{item:20} {eval(item).DGA.name}")
    else:
        return DGAs.__all__


def generate(malware, date, nr, seed, main=False, limit=True):
    if main:
        print(Col.INFO + f"* Generating domains for: {' - '.join(malware)}" + Col.END)
    domains = []
    for name in malware:
        if seed:
            family = eval(name).DGA(date=date, seed=seed)
        else:
            family = eval(name).DGA(date=date)
        if family.samples == 0 or family.samples > nr:
            max = nr
        elif not limit:
            max = nr
        else:
            max = family.samples
        if main:
            print(Col.INFO + f"* {max} domains of {name}:" + Col.END)
        for i in range(max):
            try:
                if main:
                    print(family.get_domain())
                else:
                    domains.append(family.get_domain())
            except:
                if not limit:
                    return i
    if limit:
        return domains
    else:
        return nr


def create(malware, date, nr, seed, main=False, short=False, configs=2):
    if main:
        print(Col.INFO + f"* Generating domains for: {' - '.join(malware)}" + Col.END)
    total = 0
    domains = []
    for name in malware:
        if configs == 0:        # nr of each DGA, configs doesn't matter
            configurations = [None]
            partialnr = nr
        elif configs == 1:      # nr of each DGA and each config
            configurations = eval(name).DGA.configs
            partialnr = nr
        elif configs == 2:      # nr of each DGA with configs pondered
            configurations = eval(name).DGA.configs
            partialnr = nr // len(configurations)
            first = nr - partialnr*len(configurations)
        for counter, config in enumerate(configurations):
            if counter == 0 and first:
                remain = partialnr + first
            else:
                remain = partialnr
            tempdate = date
            while remain:
                if seed:
                    family = eval(name).DGA(date=tempdate, seed=seed)
                elif config:
                    family = eval(name).DGA(date=tempdate, seed=config)
                else:
                    family = eval(name).DGA(date=tempdate)
                if family.samples == 0 or family.samples > remain:
                    max = remain
                else:
                    max = family.samples
                for i in range(max):
                    if main:
                        print(f"{family.get_domain()},{name},{config},{tempdate.strftime('%Y-%m-%d')}")
                    else:
                        if short:
                            domains.append(family.get_domain())
                        else:
                            domains.append([family.get_domain(), name, config, tempdate.strftime('%Y-%m-%d')])
                remain -= max
                total += max
                if remain and family.use_date:
                    tempdate -= timedelta(family.use_date)
                del family
    if main:
        print(Col.INFO + f"* Generated {total} domains" + Col.END)
    else:
        return domains
